<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/0.9.0/aframe.min.js"></script>
    <link rel="stylesheet" type="text/css" media="screen and (min-width: 900px)" href="mac.css">
    <link rel="stylesheet" type="text/css" media="screen and (max-width: 900px)" href="phone.css">
</head>


<body>
<button onclick="addUserLocation()">Create User Object</button>
<p>First, store your lat/lon by pressing this button.</p>
<button onclick="getLocation()">Store</button>
<p>Atlanta</p>
<button onclick="placeObjects(tech)">GT</button>
<p>Florida Objects</p>
<button onclick="placeObjects(freeman)">Dr.Freeman</button>
<form id="form1" method="get">
    Groupname:
    <input type="text" name="groupname" value="Group Name">
    <br>
    <input type="button" onclick="createGroup()" value="Group Name">
    <br>
    Add User:
    <input type="text" name="addUser" value="User Name">
    <br>
    <input type="button" onclick="addUserToGroup()" value="Add User to Group">
</form>

<div class="camera">
    <video  id="videoElement"></video>
</div>
<div id="a-scene">
    <a-scene background="color: black; transparent: true" vr-mode-ui="enabled: false">
        <a-assets>
        </a-assets>
        <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#93648D"></a-plane>
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>
        <a-sphere id="moving" radius="5" position="0 10 0" color="white"></a-sphere>
    </a-scene>
</div>
<p id="demo"></p>

<script src="https://www.gstatic.com/firebasejs/5.9.1/firebase.js"></script>
<script>
    const north = new AR(33.953149972982295, -84.6382802709262, 304, "North", 'red');
    const south = new AR(33.95212652307029, -84.63830172859832, 304, "South", 'blue');
    const east = new AR(33.95263379978259, -84.6376687272708, 304, "East", 'yellow');
    const west = new AR(33.952656048692, -84.63894009434387, 304, "West", 'purple');
    const given = new AR(33.95262935, -84.63824272, 304, "Center", 'white');
    const ryan = new AR(30.435449, -84.308163, 27,"Center",'blue');

    const n = new AR(33.775196, -84.397319, 286, "North", 'red');
    const s = new AR(33.774017, -84.397363, 286, "South", 'blue');
    const e = new AR(33.774618, -84.396867, 286, "East", 'yellow');
    const w = new AR(33.774615, -84.397792, 286, "West", 'purple');
    const g = new AR(33.774577, -84.397340, 286, "Center", 'white');



    const tech = [n, s, e, w, g];
    const freeman = [north, south, east, west, given];

    const demo = document.getElementById("demo");
    const cam = document.getElementById("camera");

    var currLat;
    var currLon;
    var currAlt;
    var currHeading;
    var currX;
    var currZ;
    var objectsPlaced = false;
    var time = 0;



    //Storing Position i.e. starting AR world
    function getLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(storePosition);
        } else {
            demo.innerHTML = "Geolocation is not supported by this browser.";
        }
    }
    function storePosition(position) {
        currLat = position.coords.latitude;
        currLon = position.coords.longitude;
        currAlt = position.coords.altitude;
        if (currLat == null || currLon == null || currAlt == null) {
            demo.innerHTML = "Lat, Lon, or Alt isn't storing";
        }
        //if (position.coords.heading != null) {
        //    currHeading = position.coords.heading;
        //} else {
        calculateHeading();
        cam.setAttribute('position', {
            x: 0,
            y: currAlt,
            z: 0
        });
        //}
        //updatePosition();
        //setInterval(updatePosition, 5000);
    }


    //Updating the Position - Occurs every 5 seconds and only updates if you move more than 7 meters
    function updatePosition() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(updatePositionHelper);
        } else {
            demo.innerHTML = "Geolocation cannot be updated.";
        }
    }
    function updatePositionHelper(position) {
        let tempLat = position.coords.latitude;
        let tempLon = position.coords.longitude;
        let tempAlt = position.coords.altitude;
        let changeInXDistance = calculateDistance(tempLat, currLat, tempLon, currLon);
        let changeInTotalDistance = Math.sqrt(Math.pow(changeInXDistance, 2) + Math.pow((tempAlt - currAlt), 2));
        let changeInBearing = calculateBearing(tempLat, currLat, tempLon, currLon);
        if ((Math.pow(changeInTotalDistance, .5) > 7)) {
            currLat = position.coords.latitude;
            currLon = position.coords.longitude;
            currAlt = position.coords.altitude;
            currX = currX + changeInXDistance * Math.sin(toRadians(changeInBearing));
            currZ = currZ + changeInXDistance * -1 * Math.cos(toRadians(changeInBearing));
            cam.setAttribute('position', {
                x: currX,
                y: currAlt,
                z: currZ
            });
        }
    }


    //Places Objects in AR
    function placeObjects(array) {
        if (!objectsPlaced) {
            var counter = 0;
            while (counter < 5) {
                //updatePosition();
                counter++;
            }
            array.forEach(function (item, index, array) {
                createObject(item);
            });
            objectsPlaced = true;
        }
    }
    function createObject(obj) {
        let distance = calculateDistance(currLat, obj.lat, currLon, obj.lon);
        let bearing = currHeading + calculateBearing(currLat, obj.lat, currLon, obj.lon);
        demo.innerHTML = "<br>Bearing: " + currHeading;
        let x = distance * Math.sin(toRadians(bearing));
        let y = obj.alt;
        let z = distance * -1 * Math.cos(toRadians(bearing));
        let el = document.createElement('a-entity');
        el.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 5,
        });
        el.setAttribute('material', {
            color: obj.color
        });
        el.setAttribute('position', {
            x: x,
            y: y,
            z: z
        });
        let sceneEl = document.querySelector('a-scene');
        sceneEl.appendChild(el);
    }







    //Collection of functions used in determining position of the user.

    //Sets current heading as the difference between North and user heading.
    function calculateHeading() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener("deviceorientation", function (event) {
                if(event.webkitCompassHeading) {
                    var compass = event.webkitCompassHeading;
                    handleOrientationEvent(compass);
                } else if (event.absolute == true) {
                    var compass = event.alpha;
                    demo.innerHTML = "<br> Heading: " + compass;
                    handleOrientationEvent(compass);
                } else {
                    demo.innerHTML = "<br>Compass Heading Not Working";
                }
            }, true);
        } else {
            demo.innerHTML = "<br>Compass Heading Not Working";
        }
    }
    function handleOrientationEvent(compass) {
        currHeading = compass;
    }
    //Calculates the distance between user's location and object's location in 2D.
    function calculateDistance(lat1, lat2, lon1, lon2) {
        const radius = 6371e3; // Radius of Earth in Meters
        let lat1radians = toRadians(lat1);
        let lat2radians = toRadians(lat2);
        let deltaLat = toRadians(lat2-lat1);
        let deltaLon = toRadians(lon2-lon1);
        let a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) + Math.cos(lat1radians) * Math.cos(lat2radians) * Math.sin(deltaLon/2) * Math.sin(deltaLon/2);
        let c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        let latlondistance = radius * c;
        return latlondistance;
    }

    //Calculates angle between user's location and object's location
    function calculateBearing(latB1, latB2, lonB1, lonB2) {
        let dLon = (lonB2-lonB1);
        let y = Math.sin(dLon) * Math.cos(latB2);
        let x = Math.cos(latB1)*Math.sin(latB2) - Math.sin(latB1)*Math.cos(latB2)*Math.cos(dLon);
        let brng = toDegrees((Math.atan2(y, x)));
        brng = (360 - ((brng + 360) % 360));
        return brng;
    }

    //Math functions
    function toDegrees(radians) {
        return radians * (180/Math.PI);
    }
    function toRadians(degrees) {
        return degrees * (Math.PI/180);
    }

    //AR Object Constructors
    function AR(lat, lon, alt) {
        AR(lat, lon, alt, '');
    }
    function AR(lat, lon, alt, name) {
        AR(lat, lon, alt, '' + name, 'white');
    }
    function AR(lat, lon, alt, name, color) {
        this.lat = lat;
        this.lon = lon;
        this.alt = alt;
        this.name = name;
        this.color = color;
    }



















    const username = localStorage.getItem("username");
    const password = localStorage.getItem("password");
    console.log(username);
    console.log(password);
    // Initialize Firebase
    var config = {
        apiKey: "AIzaSyCbUoec8Hr-DtnUk1srWlpRpGEZycTgBHI",
        authDomain: "arworldgt.firebaseapp.com",
        databaseURL: "https://arworldgt.firebaseio.com",
        projectId: "arworldgt",
        storageBucket: "",
        messagingSenderId: "1007753558225"
    };
    firebase.initializeApp(config);
    // Get a reference to the database service
    var database = firebase.database();



    function addUserLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(addUserLocationH);
        } else {
            demo.innerHTML = "Geolocation is not supported by this browser.";
        }
    }
    function addUserLocationH(position) {
        console.log("here");
        currLat = position.coords.latitude;
        currLon = position.coords.longitude;
        currAlt = position.coords.altitude;
        if (currLat == null || currLon == null || currAlt == null) {
            currLat = 0;
            currLon = 0;
            currAlt = 0;
            console.log("no geo");
        } else {
            console.log("geo");
            let user = firebase.database().ref(`/users/${username}`);
            user.update({
                location: true
            });
            writeObjectData(username, currLat, currLon, currAlt, username, false, 'black');
        }
    }

    function writeObjectData(name, latitude, longitude, altitude, username, pub, color) {
        firebase.database().ref('/objects/' + name).set({
            longitude: longitude,
            latitude: latitude,
            altitude: altitude,
            username: username,
            public: pub,
            color: color
        });
    }


    function createGroup() {
        var x = document.getElementById("form1");
        let groupname = x.elements[0].value;
        let path = `/groups/${groupname}/`;
        let groups = firebase.database().ref('/groups/');
        let exists = false;
        groups.once('value').then(function (snapshot) {
            snapshot.forEach(function (childSnapshot) {
                let groupsDB = childSnapshot.key;
                if (groupsDB === groupname) {
                    exists = true;
                }
            });
            if (!exists) {
                firebase.database().ref(path).set({
                    groupsize: 1
                });
                let newMemberRef = firebase.database().ref(path + 'members/');
                newMemberRef.update({
                    [username]: 0
                });
            } else {
                demo.innerHTML = "Group Already Exists";
            }
        });
    }


    async function inGroup(groupsize, userToAdd, pathToGroup, groupname) {
        console.log('calling');
        let result = await inGroupH(groupsize, userToAdd, pathToGroup, groupname);
        return result;
    }
    async function inGroupH(groupsize, userToAdd, pathToGroup, groupname) {
        let promise = new Promise(resolve => {
            let member = false;
            let usersInGroup = firebase.database().ref(`/groups/${groupname}/members/`);
            usersInGroup.once('value').then(function (snapshot) {
                snapshot.forEach(function (childSnapshot){
                    let userInGroup = childSnapshot.key;
                    if (userToAdd === userInGroup) {
                        console.log("useringroup");
                        member = true;
                    }
                });
            });
            setTimeout(() => resolve(member), 1000);
        });
        let value = await promise;
        return value;
    }
    async function userExists(userToAdd) {
        console.log('calling');
        let result = await userExistsH(userToAdd);
        return result;
    }
    async function userExistsH(userToAdd) {
        let promise = new Promise(resolve => {
            let exists = false;
            let users = firebase.database().ref('/users/');
            users.once('value').then(function (snapshot) {
                snapshot.forEach(function (childSnapshot) {
                    let usernameDB = childSnapshot.key;
                    console.log(usernameDB);
                    console.log(userToAdd);
                    if (usernameDB === userToAdd) {
                        exists = true;
                        console.log("userexists");
                    }
                });
            });
            setTimeout(() => resolve(exists), 1000);
        });
        let value = await promise;
        return value;
    }

    async function groupExists(groupname) {
        console.log('calling');
        let result = await groupExistsH(groupname);
        return result;
        // expected output: 'resolved'
        /*result = await callback(groupname);
        console.log(result);
        return result;
        */
    }
    async function groupExistsH(groupname) {
        let promise = new Promise(resolve => {
            let exists = false;
            let groups = firebase.database().ref('/groups/');
            groups.once('value').then(function (snapshot) {
                snapshot.forEach(function (childSnapshot) {
                    let groupnameDB = childSnapshot.key;
                    console.log(groupnameDB);
                    console.log(groupname);
                    if (groupnameDB === groupname) {
                        exists = true;
                        console.log("group exists");
                    }
                });
            });
            resolve(exists); // resolve
        });

        // wait for the promise to resolve
        let value = await promise;
        return value;
    }


    async function addUserToGroup() {
        var x = document.getElementById("form1");
        let groupname = x.elements[0].value;
        let userToAdd = x.elements[2].value;
        let pathToGroup = `/groups/${groupname}/`;
        let groupsize = 0;
        let result = await groupExists(groupname, groupExistsH());
        let result2 = await userExists(userToAdd);
        firebase.database().ref(pathToGroup + '/groupsize/').once('value').then(function (snapshot) {
            groupsize = snapshot.val();
        });
        let result3 = await inGroup(groupsize, userToAdd, pathToGroup, groupname);
        /*
            console.log("accessed");
            firebase.database().ref(pathToGroup).update({
                groupsize: groupsize + 1
            });
            let newMemberRef = firebase.database().ref(pathToGroup + 'members/');
            newMemberRef.update({
                [userToAdd]: groupsize
            });

        */

        if (!result3) {
            if (result2) {
                if (result) {
                    console.log("accessed");
                }
            }
        }
    }




















    /*
    let objects = firebase.database().ref('/objects/');
    objects.once('value').then(function (snapshot) {
        snapshot.forEach(function (childSnapshot) {
            let objLatitude = snapshot.child(`${childSnapshot.key}/latitude`).val();
            let objLongitude = snapshot.child(`${childSnapshot.key}/longitude`).val();
            let objAltitude = snapshot.child(`${childSnapshot.key}/altitude`).val();
            let objPrivacy = snapshot.child(`${childSnapshot.key}/public`).val();
            let objUsername = snapshot.child(`${childSnapshot.key}/username`).val();
            if (objPrivacy === false) {
                let creatorGroups = firebase.database().ref('/groups/');
                creatorGroups.once('value').then(function (child2Snapshot) {
                    child2Snapshot.forEach(function (child3Snapshot) {
                        let groupnames = child3Snapshot.key;
                        let temp = `/groups/${groupnames}/members`;
                        let members = firebase.database().ref(temp);
                        members.once('value').then(function (child4Snapshot) {
                            let memberNames = child4Snapshot.key;
                            child4Snapshot.forEach(function (child5Snapshot) {
                                let person = child5Snapshot.val();
                                if (person === username) {
                                    createObject(objLatitude, objLongitude, objAltitude);
                                }
                            });
                        });
                    });
                });
            } else {
            }
        });
    });
    */



/*
    function createObject(objLatitude, objLongitude, objAltitude) {
        console.log(objLatitude);
        console.log(objLongitude);
        console.log(objAltitude);
        */

        /*
        let distance = calculateDistance(currLat, objLatitude, currLon, objLongitude);
        let bearing = currHeading + calculateBearing(currLat, objLatitude, currLon, objLongitude);
        demo.innerHTML = "<br>Bearing: " + currHeading;
        let x = distance * Math.sin(toRadians(bearing));
        let y = objAltitude;
        let z = distance * -1 * Math.cos(toRadians(bearing));
        let el = document.createElement('a-entity');
        el.setAttribute('geometry', {
            primitive: 'sphere',
            radius: 5,
        });
        el.setAttribute('material', {
            color: 'white'
        });
        el.setAttribute('position', {
            x: x,
            y: y,
            z: z
        });
        let sceneEl = document.querySelector('a-scene');
        sceneEl.appendChild(el);
        */
    //}
</script>

<script>
    //Enables camera functionality
    var front = false;
    var constraints = { video: { facingMode: (front? "user" : "environment") } };
    navigator.mediaDevices.getUserMedia(constraints)
        .then(function success(stream) {
            var video = document.querySelector('video');
            if ("srcObject" in video) {
                video.srcObject = stream;
            } //else {
                //video.src = window.URL.createObjectURL(stream);
            //}
            video.setAttribute('autoplay', '');
            video.setAttribute('muted', '');
            video.setAttribute('playsinline', '');
            video.onloadedmetadata = function(e) {
                video.play();
            };
        })
        .catch(function(err) {
            console.log(err.name + ": " + err.message);
            demo.innerHTML = "<br>Camera Not Working";
        });

</script>
</body>
</html>